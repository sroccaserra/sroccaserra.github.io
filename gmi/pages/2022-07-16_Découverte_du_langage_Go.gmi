-- date: 2022-07-16
-- title: D√©couverte du langage Go

Cette semaine j'ai fait un peu de Go et j'aime bien, voil√† ce que j'ai observ√© en r√©solvant quelques probl√®mes d'Advent of Code.

## TL;DR

C'est top d'avoir un langage curly brackets qui soit typ√© statiquement et qu'on peut lancer en ligne de commande aussi facilement que du JavaScript, c'est pas si fr√©quent que √ßa, et c'est ce que je recherchais en ce moment, c'est une belle d√©couverte pour moi.

## Plus de d√©tails

### Un langage typ√© statiquement

Go est un langage typ√© statiquement, ce qui fait qu'on a beaucoup de feedback en temps r√©el sur son code, impossible d'oublier un param√®tre dans un appel de fonction ou de passer un param√®tre du mauvais type par exemple. √áa va plus loin, car s'il y a une variable d√©clar√©e mais non inutilis√©e, le programme ne compile pas. J'appr√©cie, √ßa aide √† la rigueur.

<pre>
<b>func</b> solve_01_1(numbers []<b>int</b>) <b>int</b> {
	previous := huge
	result := 0
	<b>for</b> _, n := <b>range</b> numbers {
		<b>if</b> n > previous {
			result += 1
		}
		previous = n
	}
	<b>return</b> result
}
</pre>

Ci-dessus on peut observer la signature de la fonction, `func solve_01_1(numbers []int) int`, qui prend en entr√©e une liste d'entiers (`[]int`) et qui renvoit un entier (`int`). Du classique.

On peut observer aussi le m√©canisme d'inf√©rence de type √† la d√©claration des variables bien pratique. Les variables `previous` et `result` sont d√©clar√©es sans type mais sont bien typ√©es statiquement et v√©rifi√©es par le type checker. On n'arrive pas au niveau de Haskell qui peut inf√©rer quasi tous les types d'un programme mais c'est d√©j√† bien.

### Exemple de Generics

Le syst√®me de generics a l'air bien, j'ai pu m'en servir assez intuitivement.

<pre>
///
// Declaration

<b>func</b> GetParsedLines[T <b>any</b>](parse <b>func</b>(<b>string</b>) T) []T {
    //...
}

///
// Uses

<b>func</b> GetInputLines() []<b>string</b> {
	<b>return</b> GetParsedLines(Id[string])
}

func GetInputInts() []<b>int</b> {
	return GetParsedLines(ParseInt)
}
</pre>

Ci dessus on peut observer une utilisation des generics, avec la d√©finition d'une fonction `GetParsedLines()` param√©trable, et son utilisation avec deux types diff√©rents dans `GetInputLines()` et `GetInputInts()`.

`GetParsedLines()` prend en argument une fonction `parse()`. Cette fonction `parse()` doit prendre en argument une `string` et doit renvoyer une valeur de type `T`, qui peut √™tre n'importe quel type. La fonction `GetParsedLines` d√©clare qu'elle renvoit une liste de `T`, qui doit √™tre le m√™me type renvoy√© par `parse()`.

J'ai trouv√© √ßa facile √† d√©couvrir, j'ai quasiment √©crit cette fonction √† l'instinct en m'aidant des erreurs du compilateur.

On peut imposer des contraintes sur les types param√©triques, comme `comparable` ou `Ordered`, mais je n'en ai pas trouv√© beaucoup, et je ne sais pas dans quelle mesure c'est extensible.

### Go en ligne de commande

C'est un langage typ√© statiquement qu'on peut lancer tr√®s facilement en ligne de commande üéâ, une super feature pour moi :) `go run monscript.go` et hop. √áa compense le manque de REPL (il n'y a pas de REPL officiel üòî).

### Un langage raisonnablement petit

Le langage est petit, on peut lire une grosse partie de la doc sans se faire trop mal, j'appr√©cie beaucoup les petits langages (Scheme, Lua, Smalltalk ‚ù§Ô∏è). La contrepartie c'est qu'il peut manquer certaines choses dont on a l'habitude.

- Pas de `try` / `catch`, on r√©cup√®re les erreurs en sortie de fonctions un peu comme en C
- Les collections sont limit√©es (pas de set ni de tuple par exemple, un peu comme en Lua - mais : on a quand m√™me droit √† une heap et une liste doublement cha√Æn√©e en plus des maps et tableaux dynamiques)
- Pas de `map` / `reduce` / `filter` g√©n√©riques out of the box. Il y a bien quelques personnes qui tentent de fournir des genres de libs √©quivalentes √† LoDash mais si j'ai bien compris les devs Go pr√©f√®rent tout faire √† coup de boucles `for` (voir le premier exemple ci-dessus), et pourquoi pas, on assume la simplicit√© des briques de base et un c√¥t√© imp√©ratif.
- Pas d‚Äôh√©ritage (mais du polymorphisme avec les interfaces)

Encore une fois, l‚Äôavantage de ces omissions c‚Äôest que le langage reste petit, et avec un peu de cr√©ativit√© on s‚Äôen sort. Tant que j'ai des tableaux dynamiques, des hashmap et des fonctions du premier ordre je peux travailler en g√©n√©ral.

### Autres Features

Le syst√®me d'interface est super souple, on dirait du duck typing en langage statique. Je n'ai pas vraiment pu me faire une opinion l√† dessus, √ßa a l'air pas mal pour d√©velopper de mani√®re opportuniste tout en gardant les avantages du type checker.

Le syst√®me d'erreur est bien pens√©, √ßa compense un peu le manque d'exception.

Je n'ai pas utilis√© les killer features de concurrence (les goroutines), √ßa a l'air bien ü§∑

Le syst√®me de packages / modules m'a un peu mis des b√¢tons dans les roues, √ßa s'est mieux pass√© quand j'ai compris qu'il y avait un seul package par r√©pertoire, et que les fichiers du package se partagent le m√™me namespace pour la compilation. Si j'ai bien compris √ßa fait qu'on a un namespace par r√©pertoire, que se partagent tous les fichiers du r√©pertoire. Je ne suis pas fan de √ße point, j'aime bien quand le scope de chaque fichier est isol√© mais je peux vivre avec.

## Docs et outils

Les docs sont bien, mais je suis le genre de personne qui trouve beaucoup de docs bien, je vous laisse vous faire votre opinion. C'est facile de trouver les docs de r√©f√©rence et plein d'article pour pr√©ciser des points du langage sur le blog Go (il y a un blog Go).

La lib standard est pas mal, pas aussi fournie que celle de Python mais on y trouve quand m√™me de quoi d√©coder des png par exemple.

Le langage est livr√© avec pas mal d'outils, dont un formateur de code, et il y a m√™me un language server officiel (gopls) ! Top, je peux faire des renames √† tire larigot dans Vim üéâ Globalement √ßa pr√©sage d'un langage bien outill√© pour travailler. Dommage : le formateur `go fmt` impose des tabs, dans mon √©diteur √ßa passe quand je les affiche comme 4 espaces, mais github les affiche comme huit espaces, je trouve √ßa moche ü§∑ Heureusement il y a un r√©glage perso pour la largeur des tabs dans github.

C'est facile d'installer et de g√©rer des d√©pendances avec `go get`, beaucoup plus simple qu'en Java par exemple pour comparer avec un autre langage curly brackets typ√© statiquement.

## Conclusion

Dans mon usage j'ai trouv√© que √ßa ressemble √† un Lua typ√© statiquement ou un meilleur TypeScript (des types non optionels, plus exigent, pas de point virgules, on peut le lancer facilement en ligne de commande sans installer et configurer des libs de transpilation, √ßa juste marche). Je comprends mieux l'int√©r√™t du coup, en plus c'est moins compliqu√© que Rust et un peu dans le m√™me esprit (√ßa compile en WebAssembly par exemple).

J'en ressors avec l'impression qu'avec un peu plus d'exp√©rience je pourrais tr√®s bien faire un projet c√¥t√© serveur en Go, en plus de m'en servir comme un langage de script typ√© statiquement, je suis tr√®s content d'y avoir pass√© un peu de temps üëçüèº

## R√©f√©rences

Pour aller plus loin, plein de docs :

- Documentation ~ <https://go.dev/doc/>
- A Tour of Go ~ <https://go.dev/tour/list>
- Using Go Modules ~ <https://go.dev/blog/using-go-modules>
- How to Write Go Code ~ <https://go.dev/doc/code>
- The Go Programming Language Specification ~ <https://go.dev/ref/spec>
- Go Modules Reference ~ <https://go.dev/ref/mod>
- Standard Library ~ <https://pkg.go.dev/std>
- Frequently Asked Questions (FAQ) ~ <https://go.dev/doc/faq>
- Error Handling and Go ~ <https://go.dev/blog/error-handling-and-go>

Outils :

- gopls ~ <https://pkg.go.dev/golang.org/x/tools/gopls>

## Random

C‚Äôest quoi les langages curly brackets ? C'est les langages avec beaucoup de `{` et de `}` dans leur syntaxe, pour d√©limiter les scopes de fonctions, boucles for, if et autres switch, les classes ou les structures...
Exemples de langages avec beaucoup de curly brackets : C, C++, Java, C#, JavaScript, TypeScript, Go, Rust.
Exemples de langages avec peu de curly brackets : Python, Ruby, Lisp, Lua, Smalltalk, Haskell, Elixir.

Je cherchais un langage typ√© statiquement que je pourrais lancer facilement en ligne de commande et pour lequel installer des d√©pendances serait simple. Un genre de croisement des avantages combin√©s de Java et de JavaScript. C'est un peu ce que j'ai trouv√© en Go, je trouve √ßa chouette.

Je n'aime pas forc√©ment les curly brackets, je suis content d'en avoir trouv√© un qui a ces avantages combin√©s. Il redore un peu le blason de la famille curly brackets.
J'appr√©cie beaucoup Java pour sa robustesse et ses r√©factos autos dans IntelliJ, sans doute C# me plairait aussi, mais pour lancer un script Java en ligne de commande, ou installer une lib en faisant du XML dans un .pom, je trouve √ßa un peu triste.
J'appr√©cie JavaScript pour se lancer superfacilement en ligne de commande, et tout installer avec npm install, et aussi pour sa souplesse, mais dans une grosse base de code quand je vois une variable "user" au fin fond d'un appel de fonctions et que je suis incapable de dire quels champs il a et il n'a pas, je trouve √ßa un peu triste.
Go a l'air de r√©concilier un peu tout √ßa, sans doute qu'il apporte aussi son lot de probl√®mes.

Dans la famille non curly brackets, j'avais d√©j√† trouv√© mon bonheur, avec Python et Ruby qui font quand m√™me un poil plus de v√©rifications que JavaScript (par exemple le nombre d'arguments) et qui arrivent avec une lib standard bien fournie, et Haskell qui fonctionne tr√®s bien en ligne de commande. en plus de son syst√®me de types costaud.
